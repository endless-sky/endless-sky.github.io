---
---
<html>
<head><title>Endless Sky Ship Builder</title>
<link rel="stylesheet" type="text/css" href="{{ 'assets/css/ship-builder.css' | absolute_url }}">
</head>

<body>
<!-- TODO: don't use a table to control layout -->
<table role="presentation">
<tr>
	<td class="controls">
		<p>
			<label for="sprite-selector">Select a ship sprite:</label>
			<input type="file" id="sprite-selector" name="file" title="Select a ship sprite" accept="image/png" />
		</p>

		<p>
			<label for="swizzle-select">Swizzle:</label>
			<select name="swizzle" id="swizzle-select">
				<option value="0" selected>Republic (No swizzle)</option>
				<option value="1">Unused (G &harr; B)</option>
				<option value="2">Militia (R &harr; G)</option>
				<option value="3">Unused (R &rarr; G &rarr; B &rarr; R)</option>
				<option value="4">Syndicate (R &rarr; B &rarr; G &rarr; R)</option>
				<option value="5">Merchant (R &harr; B)</option>
				<option value="6">Pirate (G &rarr; R, B &rarr; G)</option>
			</select>
			#<input title="Swizzle Number" id="swizzle-value" type="text" disabled value="0">
		</p>

		<p>
			<input type="checkbox" id="show-outline" />
			<label for="show-outline">Show collision mask</label>
		</p>

		<p class="hardpoint-type">
			<input type="button" value="gun" onclick="addPoint(this.value)" title="Create a gun mount at the selected position" />
			<input type="button" value="turret" onclick="addPoint(this.value)" title="Create a turret mount at the selected position" />
			<input type="button" value="engine" onclick="addPoint(this.value)" title="Create a engine mount at the selected position" />
		</p>
		<p>Load an image (regular resolution or @2x), click on where each hardpoint should be, then click one of the buttons above to add the selected point to a list of points (which will be shown below). You can then copy that list into your ship definition.</p>
		<pre id="points"></pre>
	</td>
	<td class="image-display">
		<canvas id="canvas"></canvas>
	</td>
</tr>
</table>
</body>

<script type="text/javascript">
document.onreadystatechange = () => { if (document.readyState === 'complete') initialize(); };

// Globals.
let reader = null;
let image = null;
// Keep track of whether the mouse button is down.
let isDragging = false;
// Coordinates of the most recent mouse click or drag in the canvas.
let xCoordinate = NaN;
let yCoordinate = NaN;
// Normal images should be shown at twice their resolution, but an image with
// "@2x" at the end of its file name will be drawn at 1x resolution.
let scale = 2;
// The color swizzle to use:
let swizzle = 0;
// Whether or not the collision mask outline(s) should be shown:
let showOutline = false;


// Add the various event listeners.
function initialize() {
	// Make sure the file reading API is available.
	if (typeof window.FileReader !== 'function') {
		window.alert('This utility requires a browser that supports the "FileReader" API');
		return;
	}

	const canvas = document.getElementById("canvas");
	canvas.addEventListener("mousedown", onMouseDown);
	canvas.addEventListener("mousemove", onMouseMove);
	document.body.addEventListener("mouseup", onMouseUp);

	// File selection callback.
	document.getElementById('sprite-selector').addEventListener('change', loadImage, { capture: false, passive: true });
	// Swizzle selection change.
	document.getElementById('swizzle-select').addEventListener('change', setSwizzle, { capture: false, passive: true });
	// Collision-mask toggle.
	document.getElementById('show-outline').addEventListener('change', setShowOutline, { capture: false, passive: true });
}


// Handle a mouse click within the canvas.
function onMouseDown(event) {
	isDragging = true;
	
	drawCoordinates(event.offsetX, event.offsetY);
}

// Handle mouse motion within the canvas. The button may or may not be down.
function onMouseMove(event) {
	if (!isDragging)
		return;
	
	drawCoordinates(event.offsetX, event.offsetY);
}

// Keep track of when the mouse button is released.
function onMouseUp(event) {
	isDragging = false;
}

// Draw a circle at the given coordinates, and update the stored coordinates.
function drawCoordinates(x, y) {
	// The center of the image is (0, 0). Each pixel counts as half of a source
	// pixel, since this is either a scaled-up image or an @2x file.
	xCoordinate = .5 * (x - .5 * canvas.width);
	yCoordinate = .5 * (y - .5 * canvas.height);

	drawImage();
}


// Draw the image.
function drawImage() {
	/** @type {HTMLCanvasElement} */
	const canvas = document.getElementById("canvas");
	const context = canvas.getContext("2d");
	context.clearRect(0, 0, canvas.width, canvas.height);
	if (image)
		context.drawImage(image, 0, 0, canvas.width, canvas.height);
	
	// Swizzle the image.
	const CHANNEL = {
		RED: 0,
		GREEN: 1,
		BLUE: 2,
		ALPHA: 3,
	};
	const SWIZZLE = [
		{ red: CHANNEL.RED, green: CHANNEL.GREEN, blue: CHANNEL.BLUE },
		{ red: CHANNEL.RED, green: CHANNEL.BLUE, blue: CHANNEL.GREEN },
		{ red: CHANNEL.GREEN, green: CHANNEL.RED, blue: CHANNEL.BLUE },
		{ red: CHANNEL.BLUE, green: CHANNEL.RED, blue: CHANNEL.GREEN },
		{ red: CHANNEL.GREEN, green: CHANNEL.BLUE, blue: CHANNEL.RED },
		{ red: CHANNEL.BLUE, green: CHANNEL.GREEN, blue: CHANNEL.RED },
		{ red: CHANNEL.GREEN, green: CHANNEL.BLUE, blue: CHANNEL.BLUE },
	][swizzle];
	const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
	const pixels = imageData.data;
	for (let i = 0; i < pixels.length; i += 4) {
		// Get each new channel value from the relevant channel.
		const red = pixels[i + SWIZZLE.red];
		const green = pixels[i + SWIZZLE.green];
		const blue = pixels[i + SWIZZLE.blue];
		pixels[i + 0] = red;
		pixels[i + 1] = green;
		pixels[i + 2] = blue;
		// No alpha adjustment.
	}
	
	if (showOutline) {
		const DIR = [
			pixels.length - 4 * canvas.width,
			pixels.length - 4 * canvas.width + 4,
			4,
			4 * canvas.width + 4,
			4 * canvas.width,
			4 * canvas.width - 4,
			pixels.length - 4,
			pixels.length - 4 * canvas.width - 4
		];

		const hasOutline = [];
		let start = 0;
		while (start < pixels.length) {
			// Find a non-empty pixel that has no outline.
			for ( ; start < pixels.length; start += 4) {
				if (pixels[start + 3]) {
					// The pixel is occupied and not an outline, start tracing.
					if (!hasOutline[start])
						break;
					// Skip to the next unoccupied pixel.
					for (start += 4; start < pixels.length; start += 4)
						if (!pixels[start + 3])
							break;
				}
			}
			if (start >= pixels.length)
				break;
		
			let pos = start;
			let d = 7;
			const directions = [];
			do {
				hasOutline[pos] = true;
				// Find the next occupied pixel.
				let firstD = d;
				let isAlone = false;
				while (true) {
					if (pixels[(pos + 3 + DIR[d]) % pixels.length])
						break;
					d = (d + 1) % 8;
					if (d == firstD) {
						isAlone = true;
						break;
					}
				}
				if (isAlone)
					break;
				directions.push(d);
				// Continue tracing the outline at that pixel.
				pos = (pos + DIR[d]) % pixels.length;
				d = (d + 6) % 8;
				// Loop until we are back where we started.
			} while (pos != start);
			
			// At least 4 points are needed to circle a transparent pixel.
			if (directions.length < 4)
				continue;
			
			// Fill raw outline (no interpolation and no simplification).
			pos = start;
			let i = 0;
			do {
				// Draw this outline pixel.
				pixels[pos + 0] = 255;
				pixels[pos + 1] = 0;
				pixels[pos + 2] = 0;
				pixels[pos + 3] = 255;
				pos = (pos + DIR[directions[i]]) % pixels.length;
				++i;
			} while (pos != start);
		}
	}
	context.putImageData(imageData, 0, 0);
	
	if (isNaN(xCoordinate) || isNaN(yCoordinate))
		return;
	const x = xCoordinate * 2 + .5 * canvas.width;
	const y = yCoordinate * 2 + .5 * canvas.height;
	
	context.beginPath();
	context.arc(x, y, 5, 0, 2 * Math.PI, false);
	context.lineWidth = 1;
	context.strokeStyle = "#FF0000";
	context.stroke();
}


// Add a named point to the list of points.
function addPoint(name)
{
	if (isNaN(xCoordinate) || isNaN(yCoordinate))
		return;
	
	document.getElementById("points").textContent += `\t${name} ${xCoordinate} ${yCoordinate}\n`;
}


// Load a reasonably-sized image file. Theoretically we can work on any file size,
// but anything that is over a certain size is going to 1) not be sized appropriately,
// and 2) bloat the Endless Sky memory requirements for no good reason.
function loadImage(changeEvent) {
	const file = changeEvent.target.files?.[0];
	if (!file) return;
	if (file.size > 3 * 1024 * 1024) {
		window.alert(`"${file.name}" is too large -- create a smaller asset!`);
		input.value = '';
		return;
	}

	// Begin loading the file.
	reader = new FileReader();
	reader.onload = createImage;
	reader.readAsDataURL(file);
	
	// The scale depends on whether this is an @2x image.
	if (file.name.lastIndexOf("@2x") == file.name.lastIndexOf(".") - 3)
		scale = 1;
	else
		scale = 2;
}

// An image file has been loaded. Convert it to an image.
function createImage() {
	image = new Image();
	image.onload = imageLoaded;
	image.src = reader.result;
}

// An image has been created. Draw it.
function imageLoaded() {
	const canvas = document.getElementById("canvas");
	canvas.width = scale * image.width;
	canvas.height = scale * image.height;
	
	xCoordinate = NaN;
	yCoordinate = NaN;
	drawImage();
	
	canvas.classList.add('has-image');
	document.getElementById("points").textContent = "";
}


function setSwizzle(changeEvent) {
	swizzle = Number(changeEvent.target.value);
	document.getElementById('swizzle-value').value = swizzle;

	drawImage();
}

function setShowOutline(changeEvent) {
	showOutline = changeEvent.target.checked;

	drawImage();
}

</script>
</html>